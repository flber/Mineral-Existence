!meta!
title: Uxn Notes
!meta!

## Uxn Notes

[Uxn](https://wiki.xxiivv.com/site/uxn.html) is an 8-bit virtual stack machine, created by [Devine](https://wiki.xxiivv.com/site/devine_lu_linvega.html), and programmed in [uxnambly](https://wiki.xxiivv.com/site/uxambly.html), a unique flavor of assembly. 
These are my notes for it.

### Opcodes

!code!
<strong>Stack</strong>
0x00	|BRK	|break		|	|
0x01	|LIT	|literal	|++	|
0x02	|	|		|	|
0x03	|POP	|pop		|a	|
0x04	|DUP	|duplicate	|a	|a a
0x05	|SWP	|swap		|a b	|b a
0x06	|OVR	|over		|a b	|a b a
0x07	|ROT	|rotate		|a b c	|b c a

<strong>Logic</strong>
0x08	|EQU	|equal		|a b	|c
0x09	|NEQ	|not equal	|a b	|c
0x0a	|GTH	|greater	|a b	|c
0x0b	|LTH	|less		|a b	|c
0x0c	|JMP	|jump		|[a]	|
0x0d	|JCN	|jump cond.	|a [b]	|
0x0e	|JSR	|jump stash	|[a]	|rs
0x0f	|STH	|stash		|a	|rs

<strong>Memory</strong>
0x10	|LDZ	|load zp	|a	|[b]
0x11	|STZ	|store zp	|a b	|
0x12	|LDR	|load rel	|a	|[b]
0x13	|STR	|store rel	|[b] a	|
0x14	|LDA	|load abs	|a*	|[b]
0x15	|STA	|store abs	|[b] a*	|
0x16	|DEI	|device in	|a	|[b]
0x17	|DEO	|device out	|[b] a	|

<strong>Arithmetic</strong>
0x18	|ADD	|add		|a b	|c
0x19	|SUB	|subtract	|a b	|c
0x1a	|MUL	|multiply	|a b	|c
0x1b	|DIV	|divide		|a b	|c
0x1c	|AND	|and		|a b	|c
0x1d	|ORA	|or		|a b	|c
0x1e	|EOR	|excl. or	|a b	|c
0x1f	|SFT	|shift		|a b	|c
!code!

### Modes

<strong>Keep mode</strong>: lets operators work without consuming items from the stack. Results are simply pushed to the top.

<strong>Short mode</strong>: allows operators to operate on 2-byte data, pushing and popping extra byte from the stack. With jump opcodes, short mode jumps to absolute memory addresses.

<strong>Return mode</strong>: sets opcodes to operate on the return stack. Certain opcodes, such as STH, already operate on the stack, so applying the return mode to those opcodes let them operate on the working stack.

### Runes

!code!
%	| macro-define
|	| pad absolute
$	| pad relative
@	| label-define
&	| sublabel-define
/	| sublabel spacer
"#"	| literal hex
.	| literal addr (zero page)
,	| literal addr (relative)
;	| literal addr (absolute)
:	| raw addr
'	| raw char
"	| raw word
!code!

### Breakdown of "Hello world"
!code!
( dev/console )

%RTN { JMP2r }

( devices )

|10 @Console    [ &pad $8 &char $1 ]

( init )

|0100 ( -> )
	
	,hello-word 

	&loop
		( send ) LDRk .Console/char DEO
		( incr ) #01 ADD
		( loop ) DUP ,&loop JCN
	POP
	
BRK

@hello-word "hello 20 "World!
!code!

In uxn, everything is a stack of data. This often means that commands seem backward, as data is added to that stack before operations can use it.

The second line (`%RTN { JMP2r }`) simply declares a macro labeled "RTN" which returns the two bytes at the top of the stack.

The next line is very interesting, and definitely confused me for a while!
!code!
|10 @Console    [ &pad $8 &char $1 ]
└──────────┘      └─────┘ └──────┘
      A              B       C
!code!
Part A starts the line by making sense. It defines a label: "Console", which is an address to the console device (at 0110). 
Part B is where things start to get a bit confusing, and where Devine's [devices](https://wiki.xxiivv.com/site/uxnemu.html) table is very helpful. The first part, `&pad`, defines a sub-label (of `Console`), which is assigned by the `$8` part to an address one byte further than the `Console` address. If you look at the previously mentioned table, you'll see that this puts us right up to the output section of the console's memory space. This sub-label is never actually called.
Part C then uses the same method as part B to assign the sub-label `char` to one bit past the `pad` label, which is the start of the "char" section of the console device!

The main part of the program starts with the line `|0100 ( -> )`, which moves us into the "system" device's memory space.
!code!
;hello-world ;print JSR2
└──────────┘ └────┘ └──┘
      A        B     C
!code!
Part A gets the address of the `hello-world` label and adds to the top of the stack. Part B then gets the address of the `print` label and pushes that to the stack, moving the first label down (really down four bytes, because each label is two bytes). The `JSR` opcode jumps the program to an address popped from the top of the stack, and the `2` modifier tells it to use two byte addresses. Because the top address is to `print`, we now move there.

The main part of the `print` section is in the `( send )` line, where the program outputs to the terminal.
!code!
( send ) DUP2 GET .Console/char DEO
└──────┘ └──┘ └─┘ └───────────┘ └─┘
   A      B    C        D        E
!code!
Part A is just a comment.
Part B duplicates the top two bytes of the stack, which here is the address to the `print` section. 
Part C consumes and adds the top item to the stack, which is that address to `print`
Part D adds the device address for the console's char byte to the stack.
Part E consumes both the device address and the address of the `print` label, which is essentially the first byte of the `"hello 20 "world` string. 

The next two lines make a bit more sense, but can be a bit unintuitive if you aren't used to working with memory address (like I am).
!code!
( incr ) #0001 ADD2
!code!
This is relatively straight-forward, it adds one byte to the item at the top of the stack, which is... the `print` address! Thus, the program now has an address on the top of the stack which points to the second byte in the `"hello 20 "world` string.

While a bit scary, I promise this next line isn't too complicated!
!code!
( loop ) DUP2 GET #00 NEQ ,&loop JNZ
         └──────┘ └─────┘ └────────┘
            A        B         C
!code!
At part A we duplicate and `GET` the two bytes at the top of the stack (remember, that's now the address to the next byte of our string), and the value at that address is compared to `#00`, the ascii null char, at part B. The `NEQ` opcode, as the name suggests, checks if its inputs are not equal. If they aren't equal, it returns a 1, and if they are equal it returns a 0.
Part C starts by adding the literal relative address of the `&loop` sub-label to the stack, and then the conditional jump operator, `JNZ`, uses the previous boolean added by part B to decide if it should jump to that address.
In this way, the loop repeats, printing each byte, until it hits a null byte, at which point it stops and returns.

And there we have it: Hello world!
